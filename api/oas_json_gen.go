// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/validate"
)

// Encode encodes DocumentEnum as json.
func (s DocumentEnum) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DocumentEnum from json.
func (s *DocumentEnum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DocumentEnum to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DocumentEnum(v) {
	case DocumentEnumCCCD:
		*s = DocumentEnumCCCD
	case DocumentEnumNEWID:
		*s = DocumentEnumNEWID
	case DocumentEnumOLDID:
		*s = DocumentEnumOLDID
	case DocumentEnumPASSPORT:
		*s = DocumentEnumPASSPORT
	case DocumentEnumDRIVERLICENSEOLD:
		*s = DocumentEnumDRIVERLICENSEOLD
	case DocumentEnumDRIVERLICENSEPET:
		*s = DocumentEnumDRIVERLICENSEPET
	case DocumentEnumCHIPID:
		*s = DocumentEnumCHIPID
	case DocumentEnumPOLICEID:
		*s = DocumentEnumPOLICEID
	case DocumentEnumARMYID:
		*s = DocumentEnumARMYID
	default:
		*s = DocumentEnum(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DocumentEnum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DocumentEnum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s FaceAntiSpoofStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s FaceAntiSpoofStatus) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.FakeCode.Set {
			e.FieldStart("fake_code")
			s.FakeCode.Encode(e)
		}
	}
	{
		if s.FakeScore.Set {
			e.FieldStart("fake_score")
			s.FakeScore.Encode(e)
		}
	}
	{
		if s.FakeType.Set {
			e.FieldStart("fake_type")
			s.FakeType.Encode(e)
		}
	}
	{
		if s.LivenessCompareScores.Set {
			e.FieldStart("liveness_compare_scores")
			s.LivenessCompareScores.Encode(e)
		}
	}
}

var jsonFieldsNameOfFaceAntiSpoofStatus = [5]string{
	0: "status",
	1: "fake_code",
	2: "fake_score",
	3: "fake_type",
	4: "liveness_compare_scores",
}

// Decode decodes FaceAntiSpoofStatus from json.
func (s *FaceAntiSpoofStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FaceAntiSpoofStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "fake_code":
			if err := func() error {
				s.FakeCode.Reset()
				if err := s.FakeCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fake_code\"")
			}
		case "fake_score":
			if err := func() error {
				s.FakeScore.Reset()
				if err := s.FakeScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fake_score\"")
			}
		case "fake_type":
			if err := func() error {
				s.FakeType.Reset()
				if err := s.FakeType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fake_type\"")
			}
		case "liveness_compare_scores":
			if err := func() error {
				s.LivenessCompareScores.Reset()
				if err := s.LivenessCompareScores.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"liveness_compare_scores\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FaceAntiSpoofStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FaceAntiSpoofStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FaceAntiSpoofStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FaceFeature as json.
func (s FaceFeature) Encode(e *jx.Encoder) {
	unwrapped := []float64(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		e.Float64(elem)
	}
	e.ArrEnd()
}

// Decode decodes FaceFeature from json.
func (s *FaceFeature) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FaceFeature to nil")
	}
	var unwrapped []float64
	if err := func() error {
		unwrapped = make([]float64, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem float64
			v, err := d.Float64()
			elem = float64(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = FaceFeature(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FaceFeature) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FaceFeature) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s FaceIDRecognitionInput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s FaceIDRecognitionInput) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("request_id")
		e.Str(s.RequestID)
	}
	{

		e.FieldStart("image")
		e.Str(s.Image)
	}
}

var jsonFieldsNameOfFaceIDRecognitionInput = [2]string{
	0: "request_id",
	1: "image",
}

// Decode decodes FaceIDRecognitionInput from json.
func (s *FaceIDRecognitionInput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FaceIDRecognitionInput to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "request_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.RequestID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_id\"")
			}
		case "image":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Image = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FaceIDRecognitionInput")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFaceIDRecognitionInput) {
					name = jsonFieldsNameOfFaceIDRecognitionInput[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FaceIDRecognitionInput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FaceIDRecognitionInput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s FaceIDRecognitionResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s FaceIDRecognitionResult) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("message")
		s.Message.Encode(e)
	}
	{
		if s.RecognitionResult != nil {
			e.FieldStart("recognition_result")
			e.ArrStart()
			for _, elem := range s.RecognitionResult {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RecognitionTime.Set {
			e.FieldStart("recognition_time")
			s.RecognitionTime.Encode(e)
		}
	}
}

var jsonFieldsNameOfFaceIDRecognitionResult = [3]string{
	0: "message",
	1: "recognition_result",
	2: "recognition_time",
}

// Decode decodes FaceIDRecognitionResult from json.
func (s *FaceIDRecognitionResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FaceIDRecognitionResult to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "recognition_result":
			if err := func() error {
				s.RecognitionResult = make([]FaceRecognitionResult, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FaceRecognitionResult
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RecognitionResult = append(s.RecognitionResult, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recognition_result\"")
			}
		case "recognition_time":
			if err := func() error {
				s.RecognitionTime.Reset()
				if err := s.RecognitionTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recognition_time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FaceIDRecognitionResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFaceIDRecognitionResult) {
					name = jsonFieldsNameOfFaceIDRecognitionResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FaceIDRecognitionResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FaceIDRecognitionResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s FaceIDRegisterInput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s FaceIDRegisterInput) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("unique_name")
		e.Str(s.UniqueName)
	}
	{

		e.FieldStart("image")
		e.Str(s.Image)
	}
	{
		if s.PersonName.Set {
			e.FieldStart("person_name")
			s.PersonName.Encode(e)
		}
	}
	{
		if s.Force.Set {
			e.FieldStart("force")
			s.Force.Encode(e)
		}
	}
}

var jsonFieldsNameOfFaceIDRegisterInput = [4]string{
	0: "unique_name",
	1: "image",
	2: "person_name",
	3: "force",
}

// Decode decodes FaceIDRegisterInput from json.
func (s *FaceIDRegisterInput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FaceIDRegisterInput to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "unique_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.UniqueName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unique_name\"")
			}
		case "image":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Image = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image\"")
			}
		case "person_name":
			if err := func() error {
				s.PersonName.Reset()
				if err := s.PersonName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"person_name\"")
			}
		case "force":
			if err := func() error {
				s.Force.Reset()
				if err := s.Force.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"force\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FaceIDRegisterInput")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFaceIDRegisterInput) {
					name = jsonFieldsNameOfFaceIDRegisterInput[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FaceIDRegisterInput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FaceIDRegisterInput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s FaceIDRegisterResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s FaceIDRegisterResult) encodeFields(e *jx.Encoder) {
	{
		if s.FaceCardAngle.Set {
			e.FieldStart("face_card_angle")
			s.FaceCardAngle.Encode(e)
		}
	}
	{

		e.FieldStart("face_loc")
		e.ArrStart()
		for _, elem := range s.FaceLoc {
			e.Int(elem)
		}
		e.ArrEnd()
	}
	{

		e.FieldStart("message")
		s.Message.Encode(e)
	}
	{
		if s.UniqueName.Set {
			e.FieldStart("unique_name")
			s.UniqueName.Encode(e)
		}
	}
	{
		if s.FaceID.Set {
			e.FieldStart("face_id")
			s.FaceID.Encode(e)
		}
	}
	{
		if s.MatchedScore.Set {
			e.FieldStart("matched_score")
			s.MatchedScore.Encode(e)
		}
	}
	{
		if s.SamePersonThr.Set {
			e.FieldStart("same_person_thr")
			s.SamePersonThr.Encode(e)
		}
	}
}

var jsonFieldsNameOfFaceIDRegisterResult = [7]string{
	0: "face_card_angle",
	1: "face_loc",
	2: "message",
	3: "unique_name",
	4: "face_id",
	5: "matched_score",
	6: "same_person_thr",
}

// Decode decodes FaceIDRegisterResult from json.
func (s *FaceIDRegisterResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FaceIDRegisterResult to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "face_card_angle":
			if err := func() error {
				s.FaceCardAngle.Reset()
				if err := s.FaceCardAngle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"face_card_angle\"")
			}
		case "face_loc":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.FaceLoc = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.FaceLoc = append(s.FaceLoc, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"face_loc\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "unique_name":
			if err := func() error {
				s.UniqueName.Reset()
				if err := s.UniqueName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unique_name\"")
			}
		case "face_id":
			if err := func() error {
				s.FaceID.Reset()
				if err := s.FaceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"face_id\"")
			}
		case "matched_score":
			if err := func() error {
				s.MatchedScore.Reset()
				if err := s.MatchedScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matched_score\"")
			}
		case "same_person_thr":
			if err := func() error {
				s.SamePersonThr.Reset()
				if err := s.SamePersonThr.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"same_person_thr\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FaceIDRegisterResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFaceIDRegisterResult) {
					name = jsonFieldsNameOfFaceIDRegisterResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FaceIDRegisterResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FaceIDRegisterResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s FaceIDResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s FaceIDResult) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("unique_name")
		e.Str(s.UniqueName)
	}
	{

		e.FieldStart("compare_score")
		e.Float64(s.CompareScore)
	}
	{

		e.FieldStart("info")
		s.Info.Encode(e)
	}
	{
		if s.PersonName.Set {
			e.FieldStart("person_name")
			s.PersonName.Encode(e)
		}
	}
}

var jsonFieldsNameOfFaceIDResult = [4]string{
	0: "unique_name",
	1: "compare_score",
	2: "info",
	3: "person_name",
}

// Decode decodes FaceIDResult from json.
func (s *FaceIDResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FaceIDResult to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "unique_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.UniqueName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unique_name\"")
			}
		case "compare_score":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.CompareScore = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compare_score\"")
			}
		case "info":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Info.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"info\"")
			}
		case "person_name":
			if err := func() error {
				s.PersonName.Reset()
				if err := s.PersonName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"person_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FaceIDResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFaceIDResult) {
					name = jsonFieldsNameOfFaceIDResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FaceIDResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FaceIDResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s FaceIDResultInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s FaceIDResultInfo) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes FaceIDResultInfo from json.
func (s *FaceIDResultInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FaceIDResultInfo to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FaceIDResultInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FaceIDResultInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FaceIDResultInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s FaceIDVerificationInput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s FaceIDVerificationInput) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("request_id")
		e.Str(s.RequestID)
	}
	{

		e.FieldStart("image_card")
		e.Str(s.ImageCard)
	}
	{

		e.FieldStart("image_live")
		e.Str(s.ImageLive)
	}
	{
		if s.ImageLive1.Set {
			e.FieldStart("image_live1")
			s.ImageLive1.Encode(e)
		}
	}
	{
		if s.ImageLive2.Set {
			e.FieldStart("image_live2")
			s.ImageLive2.Encode(e)
		}
	}
	{
		if s.ImageLive3.Set {
			e.FieldStart("image_live3")
			s.ImageLive3.Encode(e)
		}
	}
	{
		if s.Check3RandomPose.Set {
			e.FieldStart("check_3_random_pose")
			s.Check3RandomPose.Encode(e)
		}
	}
	{
		if s.Check3StraightPose.Set {
			e.FieldStart("check_3_straight_pose")
			s.Check3StraightPose.Encode(e)
		}
	}
	{
		if s.ReturnFeature.Set {
			e.FieldStart("return_feature")
			s.ReturnFeature.Encode(e)
		}
	}
	{
		if s.MaskThreshold.Set {
			e.FieldStart("mask_threshold")
			s.MaskThreshold.Encode(e)
		}
	}
	{
		if s.FakeThreshold.Set {
			e.FieldStart("fake_threshold")
			s.FakeThreshold.Encode(e)
		}
	}
	{
		if s.SimThresholdLevel1.Set {
			e.FieldStart("sim_threshold_level1")
			s.SimThresholdLevel1.Encode(e)
		}
	}
	{
		if s.SimThresholdLevel2.Set {
			e.FieldStart("sim_threshold_level2")
			s.SimThresholdLevel2.Encode(e)
		}
	}
}

var jsonFieldsNameOfFaceIDVerificationInput = [13]string{
	0:  "request_id",
	1:  "image_card",
	2:  "image_live",
	3:  "image_live1",
	4:  "image_live2",
	5:  "image_live3",
	6:  "check_3_random_pose",
	7:  "check_3_straight_pose",
	8:  "return_feature",
	9:  "mask_threshold",
	10: "fake_threshold",
	11: "sim_threshold_level1",
	12: "sim_threshold_level2",
}

// Decode decodes FaceIDVerificationInput from json.
func (s *FaceIDVerificationInput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FaceIDVerificationInput to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "request_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.RequestID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_id\"")
			}
		case "image_card":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ImageCard = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image_card\"")
			}
		case "image_live":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ImageLive = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image_live\"")
			}
		case "image_live1":
			if err := func() error {
				s.ImageLive1.Reset()
				if err := s.ImageLive1.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image_live1\"")
			}
		case "image_live2":
			if err := func() error {
				s.ImageLive2.Reset()
				if err := s.ImageLive2.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image_live2\"")
			}
		case "image_live3":
			if err := func() error {
				s.ImageLive3.Reset()
				if err := s.ImageLive3.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image_live3\"")
			}
		case "check_3_random_pose":
			if err := func() error {
				s.Check3RandomPose.Reset()
				if err := s.Check3RandomPose.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"check_3_random_pose\"")
			}
		case "check_3_straight_pose":
			if err := func() error {
				s.Check3StraightPose.Reset()
				if err := s.Check3StraightPose.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"check_3_straight_pose\"")
			}
		case "return_feature":
			if err := func() error {
				s.ReturnFeature.Reset()
				if err := s.ReturnFeature.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"return_feature\"")
			}
		case "mask_threshold":
			if err := func() error {
				s.MaskThreshold.Reset()
				if err := s.MaskThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mask_threshold\"")
			}
		case "fake_threshold":
			if err := func() error {
				s.FakeThreshold.Reset()
				if err := s.FakeThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fake_threshold\"")
			}
		case "sim_threshold_level1":
			if err := func() error {
				s.SimThresholdLevel1.Reset()
				if err := s.SimThresholdLevel1.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sim_threshold_level1\"")
			}
		case "sim_threshold_level2":
			if err := func() error {
				s.SimThresholdLevel2.Reset()
				if err := s.SimThresholdLevel2.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sim_threshold_level2\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FaceIDVerificationInput")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFaceIDVerificationInput) {
					name = jsonFieldsNameOfFaceIDVerificationInput[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FaceIDVerificationInput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FaceIDVerificationInput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s FaceIDVerificationResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s FaceIDVerificationResult) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("message")
		s.Message.Encode(e)
	}
	{

		e.FieldStart("request_id")
		e.Str(s.RequestID)
	}
	{
		if s.VerifyResult.Set {
			e.FieldStart("verify_result")
			s.VerifyResult.Encode(e)
		}
	}
	{
		if s.VerifyResultText.Set {
			e.FieldStart("verify_result_text")
			s.VerifyResultText.Encode(e)
		}
	}
	{
		if s.Sim.Set {
			e.FieldStart("sim")
			s.Sim.Encode(e)
		}
	}
	{
		if s.FaceLocCard != nil {
			e.FieldStart("face_loc_card")
			s.FaceLocCard.Encode(e)
		}
	}
	{
		if s.FaceCardAngle.Set {
			e.FieldStart("face_card_angle")
			s.FaceCardAngle.Encode(e)
		}
	}
	{
		if s.FaceLocLive != nil {
			e.FieldStart("face_loc_live")
			s.FaceLocLive.Encode(e)
		}
	}
	{
		if s.FaceLiveAngle.Set {
			e.FieldStart("face_live_angle")
			s.FaceLiveAngle.Encode(e)
		}
	}
	{
		if s.FeatureVectorFaceCard != nil {
			e.FieldStart("feature_vector_face_card")
			s.FeatureVectorFaceCard.Encode(e)
		}
	}
	{
		if s.FeatureVectorFaceLive != nil {
			e.FieldStart("feature_vector_face_live")
			s.FeatureVectorFaceLive.Encode(e)
		}
	}
	{
		if s.FaceAntiSpoofStatus.Set {
			e.FieldStart("face_anti_spoof_status")
			s.FaceAntiSpoofStatus.Encode(e)
		}
	}
	{
		if s.VerificationTime.Set {
			e.FieldStart("verification_time")
			s.VerificationTime.Encode(e)
		}
	}
	{
		if s.WearingMask.Set {
			e.FieldStart("wearing_mask")
			s.WearingMask.Encode(e)
		}
	}
	{
		if s.WearingMaskScore.Set {
			e.FieldStart("wearing_mask_score")
			s.WearingMaskScore.Encode(e)
		}
	}
}

var jsonFieldsNameOfFaceIDVerificationResult = [15]string{
	0:  "message",
	1:  "request_id",
	2:  "verify_result",
	3:  "verify_result_text",
	4:  "sim",
	5:  "face_loc_card",
	6:  "face_card_angle",
	7:  "face_loc_live",
	8:  "face_live_angle",
	9:  "feature_vector_face_card",
	10: "feature_vector_face_live",
	11: "face_anti_spoof_status",
	12: "verification_time",
	13: "wearing_mask",
	14: "wearing_mask_score",
}

// Decode decodes FaceIDVerificationResult from json.
func (s *FaceIDVerificationResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FaceIDVerificationResult to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "request_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.RequestID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_id\"")
			}
		case "verify_result":
			if err := func() error {
				s.VerifyResult.Reset()
				if err := s.VerifyResult.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verify_result\"")
			}
		case "verify_result_text":
			if err := func() error {
				s.VerifyResultText.Reset()
				if err := s.VerifyResultText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verify_result_text\"")
			}
		case "sim":
			if err := func() error {
				s.Sim.Reset()
				if err := s.Sim.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sim\"")
			}
		case "face_loc_card":
			if err := func() error {
				s.FaceLocCard = nil
				var elem FaceLocation
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.FaceLocCard = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"face_loc_card\"")
			}
		case "face_card_angle":
			if err := func() error {
				s.FaceCardAngle.Reset()
				if err := s.FaceCardAngle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"face_card_angle\"")
			}
		case "face_loc_live":
			if err := func() error {
				s.FaceLocLive = nil
				var elem FaceLocation
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.FaceLocLive = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"face_loc_live\"")
			}
		case "face_live_angle":
			if err := func() error {
				s.FaceLiveAngle.Reset()
				if err := s.FaceLiveAngle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"face_live_angle\"")
			}
		case "feature_vector_face_card":
			if err := func() error {
				s.FeatureVectorFaceCard = nil
				var elem FaceFeature
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.FeatureVectorFaceCard = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"feature_vector_face_card\"")
			}
		case "feature_vector_face_live":
			if err := func() error {
				s.FeatureVectorFaceLive = nil
				var elem FaceFeature
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.FeatureVectorFaceLive = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"feature_vector_face_live\"")
			}
		case "face_anti_spoof_status":
			if err := func() error {
				s.FaceAntiSpoofStatus.Reset()
				if err := s.FaceAntiSpoofStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"face_anti_spoof_status\"")
			}
		case "verification_time":
			if err := func() error {
				s.VerificationTime.Reset()
				if err := s.VerificationTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"verification_time\"")
			}
		case "wearing_mask":
			if err := func() error {
				s.WearingMask.Reset()
				if err := s.WearingMask.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wearing_mask\"")
			}
		case "wearing_mask_score":
			if err := func() error {
				s.WearingMaskScore.Reset()
				if err := s.WearingMaskScore.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wearing_mask_score\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FaceIDVerificationResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFaceIDVerificationResult) {
					name = jsonFieldsNameOfFaceIDVerificationResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FaceIDVerificationResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FaceIDVerificationResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FaceLocation as json.
func (s FaceLocation) Encode(e *jx.Encoder) {
	unwrapped := []int(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		e.Int(elem)
	}
	e.ArrEnd()
}

// Decode decodes FaceLocation from json.
func (s *FaceLocation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FaceLocation to nil")
	}
	var unwrapped []int
	if err := func() error {
		unwrapped = make([]int, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem int
			v, err := d.Int()
			elem = int(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = FaceLocation(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FaceLocation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FaceLocation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s FaceRecognitionResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s FaceRecognitionResult) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("face_loc")
		s.FaceLoc.Encode(e)
	}
	{

		e.FieldStart("face_size")
		e.Int(s.FaceSize)
	}
	{

		e.FieldStart("top_k")
		e.ArrStart()
		for _, elem := range s.TopK {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfFaceRecognitionResult = [3]string{
	0: "face_loc",
	1: "face_size",
	2: "top_k",
}

// Decode decodes FaceRecognitionResult from json.
func (s *FaceRecognitionResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FaceRecognitionResult to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "face_loc":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.FaceLoc.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"face_loc\"")
			}
		case "face_size":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.FaceSize = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"face_size\"")
			}
		case "top_k":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.TopK = make([]FaceIDResult, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FaceIDResult
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.TopK = append(s.TopK, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"top_k\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FaceRecognitionResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFaceRecognitionResult) {
					name = jsonFieldsNameOfFaceRecognitionResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FaceRecognitionResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FaceRecognitionResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s FaceUnregisterOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s FaceUnregisterOK) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("message")
		s.Message.Encode(e)
	}
}

var jsonFieldsNameOfFaceUnregisterOK = [1]string{
	0: "message",
}

// Decode decodes FaceUnregisterOK from json.
func (s *FaceUnregisterOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FaceUnregisterOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FaceUnregisterOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFaceUnregisterOK) {
					name = jsonFieldsNameOfFaceUnregisterOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FaceUnregisterOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FaceUnregisterOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s FaceUnregisterReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s FaceUnregisterReq) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("unique_name")
		e.Str(s.UniqueName)
	}
	{
		if s.FaceID.Set {
			e.FieldStart("face_id")
			s.FaceID.Encode(e)
		}
	}
}

var jsonFieldsNameOfFaceUnregisterReq = [2]string{
	0: "unique_name",
	1: "face_id",
}

// Decode decodes FaceUnregisterReq from json.
func (s *FaceUnregisterReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FaceUnregisterReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "unique_name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.UniqueName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unique_name\"")
			}
		case "face_id":
			if err := func() error {
				s.FaceID.Reset()
				if err := s.FaceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"face_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FaceUnregisterReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFaceUnregisterReq) {
					name = jsonFieldsNameOfFaceUnregisterReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FaceUnregisterReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FaceUnregisterReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FaceVerifyResultEnum as json.
func (s FaceVerifyResultEnum) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes FaceVerifyResultEnum from json.
func (s *FaceVerifyResultEnum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FaceVerifyResultEnum to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = FaceVerifyResultEnum(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FaceVerifyResultEnum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FaceVerifyResultEnum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FakeTypeEnum as json.
func (s FakeTypeEnum) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FakeTypeEnum from json.
func (s *FakeTypeEnum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FakeTypeEnum to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FakeTypeEnum(v) {
	case FakeTypeEnumNA:
		*s = FakeTypeEnumNA
	case FakeTypeEnumSCREEN:
		*s = FakeTypeEnumSCREEN
	case FakeTypeEnumRANDOMPOSE:
		*s = FakeTypeEnumRANDOMPOSE
	case FakeTypeEnumSTRAIGHTPOSE:
		*s = FakeTypeEnumSTRAIGHTPOSE
	default:
		*s = FakeTypeEnum(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FakeTypeEnum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FakeTypeEnum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GatewayError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s GatewayError) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfGatewayError = [1]string{
	0: "message",
}

// Decode decodes GatewayError from json.
func (s *GatewayError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GatewayError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GatewayError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGatewayError) {
					name = jsonFieldsNameOfGatewayError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GatewayError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GatewayError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IDCheckEnum as json.
func (s IDCheckEnum) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IDCheckEnum from json.
func (s *IDCheckEnum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IDCheckEnum to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IDCheckEnum(v) {
	case IDCheckEnumBW:
		*s = IDCheckEnumBW
	case IDCheckEnumCONER:
		*s = IDCheckEnumCONER
	case IDCheckEnumFAKE:
		*s = IDCheckEnumFAKE
	case IDCheckEnumPUNCH:
		*s = IDCheckEnumPUNCH
	case IDCheckEnumREAL:
		*s = IDCheckEnumREAL
	default:
		*s = IDCheckEnum(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IDCheckEnum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IDCheckEnum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IDTypeEnum as json.
func (s IDTypeEnum) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IDTypeEnum from json.
func (s *IDTypeEnum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IDTypeEnum to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IDTypeEnum(v) {
	case IDTypeEnum0:
		*s = IDTypeEnum0
	case IDTypeEnum1:
		*s = IDTypeEnum1
	default:
		*s = IDTypeEnum(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IDTypeEnum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IDTypeEnum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MaskResultEnum as json.
func (s MaskResultEnum) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes MaskResultEnum from json.
func (s *MaskResultEnum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MaskResultEnum to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch MaskResultEnum(v) {
	case MaskResultEnumYES:
		*s = MaskResultEnumYES
	case MaskResultEnumNO:
		*s = MaskResultEnumNO
	default:
		*s = MaskResultEnum(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MaskResultEnum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MaskResultEnum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s Message) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s Message) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("error_code")
		e.Str(s.ErrorCode)
	}
	{

		e.FieldStart("error_message")
		e.Str(s.ErrorMessage)
	}
	{
		if s.APIVersion.Set {
			e.FieldStart("api_version")
			s.APIVersion.Encode(e)
		}
	}
	{
		if s.CopyRight.Set {
			e.FieldStart("copy_right")
			s.CopyRight.Encode(e)
		}
	}
	{
		if s.Info.Set {
			e.FieldStart("info")
			s.Info.Encode(e)
		}
	}
}

var jsonFieldsNameOfMessage = [5]string{
	0: "error_code",
	1: "error_message",
	2: "api_version",
	3: "copy_right",
	4: "info",
}

// Decode decodes Message from json.
func (s *Message) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Message to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error_code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ErrorCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_code\"")
			}
		case "error_message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ErrorMessage = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_message\"")
			}
		case "api_version":
			if err := func() error {
				s.APIVersion.Reset()
				if err := s.APIVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api_version\"")
			}
		case "copy_right":
			if err := func() error {
				s.CopyRight.Reset()
				if err := s.CopyRight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"copy_right\"")
			}
		case "info":
			if err := func() error {
				s.Info.Reset()
				if err := s.Info.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"info\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Message")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMessage) {
					name = jsonFieldsNameOfMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Message) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Message) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s OCRResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s OCRResult) encodeFields(e *jx.Encoder) {
	{
		if s.Document.Set {
			e.FieldStart("document")
			s.Document.Encode(e)
		}
	}
	{
		if s.ResultCode.Set {
			e.FieldStart("result_code")
			s.ResultCode.Encode(e)
		}
	}
	{
		if s.ServerName.Set {
			e.FieldStart("server_name")
			s.ServerName.Encode(e)
		}
	}
	{
		if s.ServerVer.Set {
			e.FieldStart("server_ver")
			s.ServerVer.Encode(e)
		}
	}
	{
		if s.IDCheck.Set {
			e.FieldStart("id_check")
			s.IDCheck.Encode(e)
		}
	}
	{
		if s.IDFull.Set {
			e.FieldStart("id_full")
			s.IDFull.Encode(e)
		}
	}
	{
		if s.IDLogic.Set {
			e.FieldStart("id_logic")
			s.IDLogic.Encode(e)
		}
	}
	{
		if s.IDLogicMessage.Set {
			e.FieldStart("id_logic_message")
			s.IDLogicMessage.Encode(e)
		}
	}
	{
		if s.IDType.Set {
			e.FieldStart("id_type")
			s.IDType.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Idconf.Set {
			e.FieldStart("idconf")
			s.Idconf.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Nameconf.Set {
			e.FieldStart("nameconf")
			s.Nameconf.Encode(e)
		}
	}
	{
		if s.Birthday.Set {
			e.FieldStart("birthday")
			s.Birthday.Encode(e)
		}
	}
	{
		if s.Birthdayconf.Set {
			e.FieldStart("birthdayconf")
			s.Birthdayconf.Encode(e)
		}
	}
	{
		if s.Sex.Set {
			e.FieldStart("sex")
			s.Sex.Encode(e)
		}
	}
	{
		if s.Sexconf.Set {
			e.FieldStart("sexconf")
			s.Sexconf.Encode(e)
		}
	}
	{
		if s.Hometown.Set {
			e.FieldStart("hometown")
			s.Hometown.Encode(e)
		}
	}
	{
		if s.Hometownconf.Set {
			e.FieldStart("hometownconf")
			s.Hometownconf.Encode(e)
		}
	}
	{
		if s.Address.Set {
			e.FieldStart("address")
			s.Address.Encode(e)
		}
	}
	{
		if s.Addressconf.Set {
			e.FieldStart("addressconf")
			s.Addressconf.Encode(e)
		}
	}
	{
		if s.Expiry.Set {
			e.FieldStart("expiry")
			s.Expiry.Encode(e)
		}
	}
	{
		if s.Expiryconf.Set {
			e.FieldStart("expiryconf")
			s.Expiryconf.Encode(e)
		}
	}
	{
		if s.Religion.Set {
			e.FieldStart("religion")
			s.Religion.Encode(e)
		}
	}
	{
		if s.Religionconf.Set {
			e.FieldStart("religionconf")
			s.Religionconf.Encode(e)
		}
	}
	{
		if s.IssueDate.Set {
			e.FieldStart("issue_date")
			s.IssueDate.Encode(e)
		}
	}
	{
		if s.IssueDateConf.Set {
			e.FieldStart("issue_date_conf")
			s.IssueDateConf.Encode(e)
		}
	}
	{
		if s.IssueBy.Set {
			e.FieldStart("issue_by")
			s.IssueBy.Encode(e)
		}
	}
	{
		if s.IssueByConf.Set {
			e.FieldStart("issue_by_conf")
			s.IssueByConf.Encode(e)
		}
	}
	{
		if s.Ethnicity.Set {
			e.FieldStart("ethnicity")
			s.Ethnicity.Encode(e)
		}
	}
	{
		if s.Ethnicityconf.Set {
			e.FieldStart("ethnicityconf")
			s.Ethnicityconf.Encode(e)
		}
	}
	{
		if s.Characteristics.Set {
			e.FieldStart("characteristics")
			s.Characteristics.Encode(e)
		}
	}
	{
		if s.CharacteristicsConf.Set {
			e.FieldStart("characteristics_conf")
			s.CharacteristicsConf.Encode(e)
		}
	}
	{
		if s.Street.Set {
			e.FieldStart("street")
			s.Street.Encode(e)
		}
	}
	{
		if s.StreetName.Set {
			e.FieldStart("street_name")
			s.StreetName.Encode(e)
		}
	}
	{
		if s.Country.Set {
			e.FieldStart("country")
			s.Country.Encode(e)
		}
	}
	{
		if s.National.Set {
			e.FieldStart("national")
			s.National.Encode(e)
		}
	}
	{
		if s.Class.Set {
			e.FieldStart("class")
			s.Class.Encode(e)
		}
	}
	{
		if s.OptinalData.Set {
			e.FieldStart("optinal_data")
			s.OptinalData.Encode(e)
		}
	}
	{
		if s.PassportType.Set {
			e.FieldStart("passport_type")
			s.PassportType.Encode(e)
		}
	}
	{
		if s.Province.Set {
			e.FieldStart("province")
			s.Province.Encode(e)
		}
	}
	{
		if s.District.Set {
			e.FieldStart("district")
			s.District.Encode(e)
		}
	}
	{
		if s.Precinct.Set {
			e.FieldStart("precinct")
			s.Precinct.Encode(e)
		}
	}
	{
		if s.OptionalData.Set {
			e.FieldStart("optional_data")
			s.OptionalData.Encode(e)
		}
	}
	{
		if s.Copyright.Set {
			e.FieldStart("copyright")
			s.Copyright.Encode(e)
		}
	}
}

var jsonFieldsNameOfOCRResult = [45]string{
	0:  "document",
	1:  "result_code",
	2:  "server_name",
	3:  "server_ver",
	4:  "id_check",
	5:  "id_full",
	6:  "id_logic",
	7:  "id_logic_message",
	8:  "id_type",
	9:  "id",
	10: "idconf",
	11: "name",
	12: "nameconf",
	13: "birthday",
	14: "birthdayconf",
	15: "sex",
	16: "sexconf",
	17: "hometown",
	18: "hometownconf",
	19: "address",
	20: "addressconf",
	21: "expiry",
	22: "expiryconf",
	23: "religion",
	24: "religionconf",
	25: "issue_date",
	26: "issue_date_conf",
	27: "issue_by",
	28: "issue_by_conf",
	29: "ethnicity",
	30: "ethnicityconf",
	31: "characteristics",
	32: "characteristics_conf",
	33: "street",
	34: "street_name",
	35: "country",
	36: "national",
	37: "class",
	38: "optinal_data",
	39: "passport_type",
	40: "province",
	41: "district",
	42: "precinct",
	43: "optional_data",
	44: "copyright",
}

// Decode decodes OCRResult from json.
func (s *OCRResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OCRResult to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "document":
			if err := func() error {
				s.Document.Reset()
				if err := s.Document.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"document\"")
			}
		case "result_code":
			if err := func() error {
				s.ResultCode.Reset()
				if err := s.ResultCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result_code\"")
			}
		case "server_name":
			if err := func() error {
				s.ServerName.Reset()
				if err := s.ServerName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"server_name\"")
			}
		case "server_ver":
			if err := func() error {
				s.ServerVer.Reset()
				if err := s.ServerVer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"server_ver\"")
			}
		case "id_check":
			if err := func() error {
				s.IDCheck.Reset()
				if err := s.IDCheck.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id_check\"")
			}
		case "id_full":
			if err := func() error {
				s.IDFull.Reset()
				if err := s.IDFull.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id_full\"")
			}
		case "id_logic":
			if err := func() error {
				s.IDLogic.Reset()
				if err := s.IDLogic.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id_logic\"")
			}
		case "id_logic_message":
			if err := func() error {
				s.IDLogicMessage.Reset()
				if err := s.IDLogicMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id_logic_message\"")
			}
		case "id_type":
			if err := func() error {
				s.IDType.Reset()
				if err := s.IDType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id_type\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "idconf":
			if err := func() error {
				s.Idconf.Reset()
				if err := s.Idconf.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"idconf\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "nameconf":
			if err := func() error {
				s.Nameconf.Reset()
				if err := s.Nameconf.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nameconf\"")
			}
		case "birthday":
			if err := func() error {
				s.Birthday.Reset()
				if err := s.Birthday.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthday\"")
			}
		case "birthdayconf":
			if err := func() error {
				s.Birthdayconf.Reset()
				if err := s.Birthdayconf.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"birthdayconf\"")
			}
		case "sex":
			if err := func() error {
				s.Sex.Reset()
				if err := s.Sex.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sex\"")
			}
		case "sexconf":
			if err := func() error {
				s.Sexconf.Reset()
				if err := s.Sexconf.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sexconf\"")
			}
		case "hometown":
			if err := func() error {
				s.Hometown.Reset()
				if err := s.Hometown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hometown\"")
			}
		case "hometownconf":
			if err := func() error {
				s.Hometownconf.Reset()
				if err := s.Hometownconf.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hometownconf\"")
			}
		case "address":
			if err := func() error {
				s.Address.Reset()
				if err := s.Address.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "addressconf":
			if err := func() error {
				s.Addressconf.Reset()
				if err := s.Addressconf.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addressconf\"")
			}
		case "expiry":
			if err := func() error {
				s.Expiry.Reset()
				if err := s.Expiry.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiry\"")
			}
		case "expiryconf":
			if err := func() error {
				s.Expiryconf.Reset()
				if err := s.Expiryconf.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiryconf\"")
			}
		case "religion":
			if err := func() error {
				s.Religion.Reset()
				if err := s.Religion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"religion\"")
			}
		case "religionconf":
			if err := func() error {
				s.Religionconf.Reset()
				if err := s.Religionconf.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"religionconf\"")
			}
		case "issue_date":
			if err := func() error {
				s.IssueDate.Reset()
				if err := s.IssueDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_date\"")
			}
		case "issue_date_conf":
			if err := func() error {
				s.IssueDateConf.Reset()
				if err := s.IssueDateConf.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_date_conf\"")
			}
		case "issue_by":
			if err := func() error {
				s.IssueBy.Reset()
				if err := s.IssueBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_by\"")
			}
		case "issue_by_conf":
			if err := func() error {
				s.IssueByConf.Reset()
				if err := s.IssueByConf.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issue_by_conf\"")
			}
		case "ethnicity":
			if err := func() error {
				s.Ethnicity.Reset()
				if err := s.Ethnicity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ethnicity\"")
			}
		case "ethnicityconf":
			if err := func() error {
				s.Ethnicityconf.Reset()
				if err := s.Ethnicityconf.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ethnicityconf\"")
			}
		case "characteristics":
			if err := func() error {
				s.Characteristics.Reset()
				if err := s.Characteristics.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"characteristics\"")
			}
		case "characteristics_conf":
			if err := func() error {
				s.CharacteristicsConf.Reset()
				if err := s.CharacteristicsConf.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"characteristics_conf\"")
			}
		case "street":
			if err := func() error {
				s.Street.Reset()
				if err := s.Street.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"street\"")
			}
		case "street_name":
			if err := func() error {
				s.StreetName.Reset()
				if err := s.StreetName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"street_name\"")
			}
		case "country":
			if err := func() error {
				s.Country.Reset()
				if err := s.Country.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"country\"")
			}
		case "national":
			if err := func() error {
				s.National.Reset()
				if err := s.National.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"national\"")
			}
		case "class":
			if err := func() error {
				s.Class.Reset()
				if err := s.Class.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"class\"")
			}
		case "optinal_data":
			if err := func() error {
				s.OptinalData.Reset()
				if err := s.OptinalData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optinal_data\"")
			}
		case "passport_type":
			if err := func() error {
				s.PassportType.Reset()
				if err := s.PassportType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passport_type\"")
			}
		case "province":
			if err := func() error {
				s.Province.Reset()
				if err := s.Province.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"province\"")
			}
		case "district":
			if err := func() error {
				s.District.Reset()
				if err := s.District.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"district\"")
			}
		case "precinct":
			if err := func() error {
				s.Precinct.Reset()
				if err := s.Precinct.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"precinct\"")
			}
		case "optional_data":
			if err := func() error {
				s.OptionalData.Reset()
				if err := s.OptionalData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optional_data\"")
			}
		case "copyright":
			if err := func() error {
				s.Copyright.Reset()
				if err := s.Copyright.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"copyright\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OCRResult")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OCRResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OCRResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OCRResultResultCode as json.
func (s OCRResultResultCode) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes OCRResultResultCode from json.
func (s *OCRResultResultCode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OCRResultResultCode to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = OCRResultResultCode(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OCRResultResultCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OCRResultResultCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DocumentEnum as json.
func (o OptDocumentEnum) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DocumentEnum from json.
func (o *OptDocumentEnum) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDocumentEnum to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDocumentEnum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDocumentEnum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FaceAntiSpoofStatus as json.
func (o OptFaceAntiSpoofStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FaceAntiSpoofStatus from json.
func (o *OptFaceAntiSpoofStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFaceAntiSpoofStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFaceAntiSpoofStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFaceAntiSpoofStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FaceVerifyResultEnum as json.
func (o OptFaceVerifyResultEnum) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes FaceVerifyResultEnum from json.
func (o *OptFaceVerifyResultEnum) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFaceVerifyResultEnum to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFaceVerifyResultEnum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFaceVerifyResultEnum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FakeTypeEnum as json.
func (o OptFakeTypeEnum) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes FakeTypeEnum from json.
func (o *OptFakeTypeEnum) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFakeTypeEnum to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFakeTypeEnum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFakeTypeEnum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IDCheckEnum as json.
func (o OptIDCheckEnum) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes IDCheckEnum from json.
func (o *OptIDCheckEnum) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIDCheckEnum to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIDCheckEnum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIDCheckEnum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IDTypeEnum as json.
func (o OptIDTypeEnum) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes IDTypeEnum from json.
func (o *OptIDTypeEnum) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIDTypeEnum to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIDTypeEnum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIDTypeEnum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MaskResultEnum as json.
func (o OptMaskResultEnum) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes MaskResultEnum from json.
func (o *OptMaskResultEnum) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMaskResultEnum to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMaskResultEnum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMaskResultEnum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OCRResultResultCode as json.
func (o OptOCRResultResultCode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes OCRResultResultCode from json.
func (o *OptOCRResultResultCode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOCRResultResultCode to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOCRResultResultCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOCRResultResultCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpoofStatusEnum as json.
func (o OptSpoofStatusEnum) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SpoofStatusEnum from json.
func (o *OptSpoofStatusEnum) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSpoofStatusEnum to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSpoofStatusEnum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSpoofStatusEnum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpoofStatusEnum as json.
func (s SpoofStatusEnum) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SpoofStatusEnum from json.
func (s *SpoofStatusEnum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpoofStatusEnum to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SpoofStatusEnum(v) {
	case SpoofStatusEnumFAKE:
		*s = SpoofStatusEnumFAKE
	case SpoofStatusEnumREAL:
		*s = SpoofStatusEnumREAL
	default:
		*s = SpoofStatusEnum(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpoofStatusEnum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpoofStatusEnum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
